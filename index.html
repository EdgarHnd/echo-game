<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ECHO</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  overflow: hidden; 
  background: #000; 
  font-family: 'Segoe UI', system-ui, sans-serif;
}
canvas { display: block; }

#ui {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}

#danger-vignette {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 5;
  opacity: 0;
  transition: opacity 0.2s;
}

#level-display {
  position: absolute;
  top: 25px;
  left: 30px;
  color: rgba(255, 255, 255, 0.4);
  font-size: 12px;
  letter-spacing: 5px;
  text-transform: uppercase;
}

#pulse-count {
  position: absolute;
  top: 25px;
  right: 30px;
  color: rgba(0, 255, 255, 0.5);
  font-size: 12px;
  letter-spacing: 4px;
}

#pulse-count span {
  font-size: 32px;
  font-weight: 100;
  color: rgba(0, 255, 255, 0.7);
}

#fragment-count {
  position: absolute;
  top: 55px;
  right: 30px;
  color: rgba(0, 255, 170, 0.5);
  font-size: 12px;
  letter-spacing: 4px;
}

#message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  font-size: 14px;
  letter-spacing: 8px;
  text-transform: uppercase;
  opacity: 0;
  transition: opacity 0.5s;
  text-shadow: 0 0 25px rgba(255, 255, 255, 0.4);
  text-align: center;
  line-height: 2;
}

#instructions {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.15);
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 20;
  pointer-events: all;
  background: rgba(0, 0, 0, 0.97);
}

#title-screen {
  display: flex;
  background: #000;
}

#title-screen h1 {
  font-size: 70px;
  font-weight: 100;
  letter-spacing: 25px;
  color: rgba(255, 255, 255, 0.85);
  text-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
  margin-bottom: 10px;
}

.subtitle {
  font-size: 11px;
  letter-spacing: 5px;
  color: rgba(255, 255, 255, 0.2);
  margin-bottom: 50px;
  text-transform: uppercase;
  text-align: center;
  line-height: 2;
}

.btn {
  font-size: 12px;
  letter-spacing: 5px;
  color: rgba(0, 255, 255, 0.6);
  border: 1px solid rgba(0, 255, 255, 0.15);
  padding: 12px 30px;
  cursor: pointer;
  background: transparent;
  font-family: inherit;
  transition: all 0.3s;
  text-transform: uppercase;
}

.btn:hover {
  background: rgba(0, 255, 255, 0.05);
  border-color: rgba(0, 255, 255, 0.4);
  text-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
}

#death-screen h2 {
  font-size: 36px;
  font-weight: 100;
  letter-spacing: 15px;
  color: #ff3333;
  text-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
  margin-bottom: 25px;
}

#win-screen h2 {
  font-size: 36px;
  font-weight: 100;
  letter-spacing: 15px;
  color: #00ff88;
  text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
  margin-bottom: 25px;
}

.stats {
  color: rgba(255, 255, 255, 0.4);
  font-size: 12px;
  letter-spacing: 3px;
  margin-bottom: 35px;
  text-align: center;
  line-height: 2;
}
</style>
</head>
<body>

<div id="danger-vignette"></div>

<div id="ui">
  <div id="level-display">Level <span id="level-num">1</span></div>
  <div id="pulse-count">Pulses <span id="pulses">0</span></div>
  <div id="fragment-count">Fragments <span id="frags">0</span>/<span id="frags-total">0</span></div>
  <div id="message"></div>
  <div id="instructions">Hold Space or Click to pulse · WASD to move</div>
</div>

<div class="overlay" id="title-screen">
  <h1>ECHO</h1>
  <div class="subtitle">
    Sound is sight in the dark<br>
    But they listen too
  </div>
  <button class="btn" id="start-btn">Enter</button>
</div>

<div class="overlay" id="death-screen">
  <h2>FOUND</h2>
  <div class="stats">
    <div>It heard you</div>
    <div style="margin-top: 15px;">Level <span id="death-level">1</span> · <span id="death-pulses">0</span> pulses</div>
  </div>
  <button class="btn" id="retry-btn">Again</button>
</div>

<div class="overlay" id="win-screen">
  <h2>ESCAPED</h2>
  <div class="stats">
    <div>You found the way</div>
    <div style="margin-top: 15px;">Total pulses: <span id="win-pulses">0</span></div>
  </div>
  <button class="btn" id="replay-btn">Again</button>
</div>

<canvas id="game"></canvas>

<script>
// ============ AUDIO ============
let audioCtx = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  
  // Ambient drone
  const rumble = audioCtx.createOscillator();
  const rumbleGain = audioCtx.createGain();
  rumble.type = 'sine';
  rumble.frequency.value = 28;
  rumbleGain.gain.value = 0.03;
  rumble.connect(rumbleGain);
  rumbleGain.connect(audioCtx.destination);
  rumble.start();
}

function playPulseSound(intensity) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.frequency.setValueAtTime(400 + intensity * 500, t);
  osc.frequency.exponentialRampToValueAtTime(60, t + 0.5);
  
  filter.type = 'bandpass';
  filter.frequency.value = 700;
  
  gain.gain.setValueAtTime(0.06 + intensity * 0.05, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
  
  osc.start(t);
  osc.stop(t + 0.5);
  
  // Bass thump
  if (intensity > 0.3) {
    const bass = audioCtx.createOscillator();
    const bassGain = audioCtx.createGain();
    bass.connect(bassGain);
    bassGain.connect(audioCtx.destination);
    bass.type = 'sine';
    bass.frequency.setValueAtTime(45, t);
    bass.frequency.exponentialRampToValueAtTime(20, t + 0.15);
    bassGain.gain.setValueAtTime(0.1 * intensity, t);
    bassGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    bass.start(t);
    bass.stop(t + 0.15);
  }
}

function playEchoSound(distance, type) {
  if (!audioCtx) return;
  
  const delay = Math.min(distance / 500, 0.4);
  
  setTimeout(function() {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    if (type === 'hunter') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(180, t);
      osc.frequency.exponentialRampToValueAtTime(70, t + 0.15);
      filter.type = 'lowpass';
      filter.frequency.value = 350;
    } else if (type === 'fragment') {
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
      filter.type = 'highpass';
      filter.frequency.value = 700;
    } else if (type === 'exit') {
      osc.frequency.setValueAtTime(1000, t);
      osc.frequency.exponentialRampToValueAtTime(650, t + 0.12);
      filter.type = 'bandpass';
      filter.frequency.value = 850;
    } else {
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.exponentialRampToValueAtTime(130, t + 0.1);
      filter.type = 'bandpass';
      filter.frequency.value = 650;
    }
    
    const vol = Math.max(0.005, 0.045 - distance / 2500);
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    
    osc.start(t);
    osc.stop(t + 0.15);
  }, delay * 1000);
}

function playHeartbeat(intensity) {
  if (!audioCtx || intensity < 0.2) return;
  const t = audioCtx.currentTime;
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.type = 'sine';
  osc.frequency.setValueAtTime(55, t);
  osc.frequency.exponentialRampToValueAtTime(35, t + 0.1);
  gain.gain.setValueAtTime(0.07 * intensity, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  
  osc.start(t);
  osc.stop(t + 0.1);
  
  setTimeout(function() {
    if (!audioCtx) return;
    const t2 = audioCtx.currentTime;
    const osc2 = audioCtx.createOscillator();
    const gain2 = audioCtx.createGain();
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);
    osc2.type = 'sine';
    osc2.frequency.value = 42;
    gain2.gain.setValueAtTime(0.04 * intensity, t2);
    gain2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.07);
    osc2.start(t2);
    osc2.stop(t2 + 0.07);
  }, 90);
}

function playHunterGrowl(distance, alertLevel) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  
  const vol = Math.max(0.01, (0.08 - distance / 1000) * alertLevel);
  
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  
  osc1.connect(filter);
  osc2.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc1.type = 'sawtooth';
  osc2.type = 'sawtooth';
  osc1.frequency.value = 50 + alertLevel * 12;
  osc2.frequency.value = 53 + alertLevel * 12;
  
  filter.type = 'lowpass';
  filter.frequency.value = 120 + alertLevel * 70;
  
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  
  osc1.start(t);
  osc2.start(t);
  osc1.stop(t + 0.35);
  osc2.stop(t + 0.35);
}

function playTerrorSound() {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  
  [175, 186, 197, 209].forEach(function(freq) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.045, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.55);
    osc.start(t);
    osc.stop(t + 0.55);
  });
}

function playCollectSound() {
  if (!audioCtx) return;
  
  [750, 950, 1150].forEach(function(freq, i) {
    setTimeout(function() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.start(t);
      osc.stop(t + 0.12);
    }, i * 55);
  });
}

function playUnlockSound() {
  if (!audioCtx) return;
  
  [380, 480, 580, 730, 920].forEach(function(freq, i) {
    setTimeout(function() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.07, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      osc.start(t);
      osc.stop(t + 0.2);
    }, i * 70);
  });
}

function playDeathSound() {
  if (!audioCtx) return;
  
  for (let i = 0; i < 7; i++) {
    setTimeout(function() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(130 - i * 10, t);
      osc.frequency.exponentialRampToValueAtTime(15, t + 0.3);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.start(t);
      osc.stop(t + 0.3);
    }, i * 40);
  }
}

function playWinSound() {
  if (!audioCtx) return;
  
  [523, 659, 784, 1047].forEach(function(freq, i) {
    setTimeout(function() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
      osc.start(t);
      osc.stop(t + 0.28);
    }, i * 85);
  });
}

// ============ GAME ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let width, height;

// Game state
let gameState = 'title';
let currentLevel = 0;
let totalPulses = 0;

// Arrays
let pulses = [];
let revealedGeo = [];
let memoryGeo = [];
let particles = [];
let hunters = [];
let fragments = [];
let walls = [];

// Player
let player = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0,
  radius: 8
};

// Exit
let exit = {
  x: 0,
  y: 0,
  radius: 22,
  open: false
};

// Input
let keys = {};
let isCharging = false;
let chargeTime = 0;
const MAX_CHARGE = 650;
const MIN_CHARGE = 60;

// Effects
let screenShake = { x: 0, y: 0, intensity: 0 };
let slowMo = { active: false, factor: 1, duration: 0 };
let dangerLevel = 0;
let heartbeatTimer = 0;
let fragmentsCollected = 0;

// Timing
let lastTime = 0;

// ============ LEVELS ============
const levels = [
  // Level 1: Tutorial - no hunters
  {
    playerStart: { x: 120, y: 300 },
    exitPos: { x: 680, y: 300 },
    hunterData: [],
    fragmentData: [{ x: 400, y: 180 }, { x: 400, y: 420 }],
    createWalls: function(w, h) {
      return [
        { x1: 50, y1: 50, x2: w - 50, y2: 50 },
        { x1: w - 50, y1: 50, x2: w - 50, y2: h - 50 },
        { x1: w - 50, y1: h - 50, x2: 50, y2: h - 50 },
        { x1: 50, y1: h - 50, x2: 50, y2: 50 },
        { x1: 300, y1: 100, x2: 300, y2: 380 },
        { x1: 500, y1: 220, x2: 500, y2: 500 }
      ];
    }
  },
  // Level 2: First hunter
  {
    playerStart: { x: 100, y: 300 },
    exitPos: { x: 700, y: 300 },
    hunterData: [{ x: 400, y: 300, speed: 70, patrolRadius: 110 }],
    fragmentData: [{ x: 250, y: 150 }, { x: 550, y: 450 }, { x: 400, y: 300 }],
    createWalls: function(w, h) {
      return [
        { x1: 50, y1: 50, x2: w - 50, y2: 50 },
        { x1: w - 50, y1: 50, x2: w - 50, y2: h - 50 },
        { x1: w - 50, y1: h - 50, x2: 50, y2: h - 50 },
        { x1: 50, y1: h - 50, x2: 50, y2: 50 },
        { x1: 250, y1: 80, x2: 250, y2: 350 },
        { x1: 550, y1: 250, x2: 550, y2: 520 }
      ];
    }
  },
  // Level 3: Maze
  {
    playerStart: { x: 100, y: 100 },
    exitPos: { x: 700, y: 500 },
    hunterData: [{ x: 400, y: 300, speed: 80, patrolRadius: 130 }],
    fragmentData: [{ x: 150, y: 400 }, { x: 400, y: 150 }, { x: 600, y: 350 }, { x: 350, y: 480 }],
    createWalls: function(w, h) {
      return [
        { x1: 50, y1: 50, x2: w - 50, y2: 50 },
        { x1: w - 50, y1: 50, x2: w - 50, y2: h - 50 },
        { x1: w - 50, y1: h - 50, x2: 50, y2: h - 50 },
        { x1: 50, y1: h - 50, x2: 50, y2: 50 },
        { x1: 200, y1: 50, x2: 200, y2: 300 },
        { x1: 200, y1: 380, x2: 200, y2: h - 50 },
        { x1: 350, y1: 130, x2: 350, y2: 450 },
        { x1: 500, y1: 50, x2: 500, y2: 360 },
        { x1: 500, y1: 360, x2: 640, y2: 360 }
      ];
    }
  },
  // Level 4: Two hunters
  {
    playerStart: { x: 400, y: 550 },
    exitPos: { x: 400, y: 80 },
    hunterData: [
      { x: 200, y: 300, speed: 75, patrolRadius: 90 },
      { x: 600, y: 300, speed: 75, patrolRadius: 90 }
    ],
    fragmentData: [{ x: 400, y: 300 }, { x: 200, y: 150 }, { x: 600, y: 450 }, { x: 300, y: 450 }, { x: 500, y: 150 }],
    createWalls: function(w, h) {
      return [
        { x1: 50, y1: 50, x2: w - 50, y2: 50 },
        { x1: w - 50, y1: 50, x2: w - 50, y2: h - 50 },
        { x1: w - 50, y1: h - 50, x2: 50, y2: h - 50 },
        { x1: 50, y1: h - 50, x2: 50, y2: 50 },
        { x1: 270, y1: 170, x2: 270, y2: 430 },
        { x1: 530, y1: 170, x2: 530, y2: 430 },
        { x1: 270, y1: 170, x2: 530, y2: 170 },
        { x1: 270, y1: 430, x2: 530, y2: 430 }
      ];
    }
  },
  // Level 5: The Gauntlet
  {
    playerStart: { x: 100, y: 300 },
    exitPos: { x: 700, y: 300 },
    hunterData: [
      { x: 250, y: 170, speed: 85, patrolRadius: 65 },
      { x: 400, y: 430, speed: 85, patrolRadius: 65 },
      { x: 550, y: 170, speed: 85, patrolRadius: 65 }
    ],
    fragmentData: [{ x: 200, y: 300 }, { x: 350, y: 200 }, { x: 450, y: 400 }, { x: 600, y: 300 }, { x: 400, y: 300 }],
    createWalls: function(w, h) {
      return [
        { x1: 50, y1: 50, x2: w - 50, y2: 50 },
        { x1: w - 50, y1: 50, x2: w - 50, y2: h - 50 },
        { x1: w - 50, y1: h - 50, x2: 50, y2: h - 50 },
        { x1: 50, y1: h - 50, x2: 50, y2: 50 },
        { x1: 50, y1: 195, x2: 170, y2: 195 },
        { x1: 50, y1: 405, x2: 170, y2: 405 },
        { x1: 290, y1: 95, x2: 290, y2: 255 },
        { x1: 290, y1: 345, x2: 290, y2: 505 },
        { x1: 510, y1: 95, x2: 510, y2: 255 },
        { x1: 510, y1: 345, x2: 510, y2: 505 },
        { x1: 630, y1: 195, x2: w - 50, y2: 195 },
        { x1: 630, y1: 405, x2: w - 50, y2: 405 }
      ];
    }
  }
];

// ============ UTILITY ============
function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let t = lenSq !== 0 ? dot / lenSq : -1;
  
  if (t < 0) t = 0;
  else if (t > 1) t = 1;
  
  const nearX = x1 + t * C;
  const nearY = y1 + t * D;
  
  return Math.hypot(px - nearX, py - nearY);
}

function circleLineCollision(cx, cy, radius, x1, y1, x2, y2) {
  return pointToLineDistance(cx, cy, x1, y1, x2, y2) < radius;
}

// ============ GAME FUNCTIONS ============
function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}

function loadLevel(levelIndex) {
  if (levelIndex >= levels.length) {
    gameState = 'won';
    document.getElementById('win-screen').style.display = 'flex';
    document.getElementById('win-pulses').textContent = totalPulses;
    playWinSound();
    return;
  }
  
  const level = levels[levelIndex];
  currentLevel = levelIndex;
  
  // Reset arrays
  pulses = [];
  revealedGeo = [];
  memoryGeo = [];
  particles = [];
  hunters = [];
  fragments = [];
  fragmentsCollected = 0;
  
  // Set player
  player.x = level.playerStart.x;
  player.y = level.playerStart.y;
  player.vx = 0;
  player.vy = 0;
  
  // Set exit
  exit.x = level.exitPos.x;
  exit.y = level.exitPos.y;
  exit.open = level.fragmentData.length === 0;
  
  // Create walls
  walls = level.createWalls(width, height);
  
  // Create hunters
  level.hunterData.forEach(function(h) {
    hunters.push({
      x: h.x,
      y: h.y,
      homeX: h.x,
      homeY: h.y,
      speed: h.speed,
      patrolRadius: h.patrolRadius,
      patrolAngle: Math.random() * Math.PI * 2,
      state: 'patrol',
      alertLevel: 0,
      lastHeardX: null,
      lastHeardY: null,
      investigateTimer: 0,
      stepTimer: 0,
      radius: 24
    });
  });
  
  // Create fragments
  level.fragmentData.forEach(function(f) {
    fragments.push({
      x: f.x,
      y: f.y,
      radius: 12,
      collected: false,
      revealAlpha: 0
    });
  });
  
  // Update UI
  document.getElementById('level-num').textContent = levelIndex + 1;
  document.getElementById('pulses').textContent = totalPulses;
  document.getElementById('frags').textContent = '0';
  document.getElementById('frags-total').textContent = fragments.length;
  
  // Show message
  if (levelIndex === 0) {
    showMessage('Collect fragments<br>Find the exit');
  } else {
    showMessage('Level ' + (levelIndex + 1));
  }
}

function showMessage(text, duration) {
  duration = duration || 2200;
  const msg = document.getElementById('message');
  msg.innerHTML = text;
  msg.style.opacity = '1';
  setTimeout(function() {
    msg.style.opacity = '0';
  }, duration);
}

function startGame() {
  initAudio();
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
  
  totalPulses = 0;
  gameState = 'playing';
  loadLevel(0);
}

function emitPulse(intensity) {
  if (gameState !== 'playing') return;
  
  totalPulses++;
  document.getElementById('pulses').textContent = totalPulses;
  
  pulses.push({
    x: player.x,
    y: player.y,
    radius: 0,
    maxRadius: 160 + intensity * 450,
    speed: 250 + intensity * 150,
    alpha: 1,
    intensity: intensity
  });
  
  playPulseSound(intensity);
  screenShake.intensity = 2 + intensity * 5;
  
  // Spawn particles
  const count = 6 + Math.floor(intensity * 10);
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2;
    particles.push({
      x: player.x,
      y: player.y,
      vx: Math.cos(angle) * (70 + intensity * 50),
      vy: Math.sin(angle) * (70 + intensity * 50),
      life: 0.35 + intensity * 0.25,
      maxLife: 0.35 + intensity * 0.25
    });
  }
  
  // Alert hunters
  hunters.forEach(function(hunter) {
    const dist = Math.hypot(hunter.x - player.x, hunter.y - player.y);
    const hearingRange = 200 + intensity * 400;
    
    if (dist < hearingRange) {
      hunter.lastHeardX = player.x;
      hunter.lastHeardY = player.y;
      hunter.alertLevel = Math.min(1, hunter.alertLevel + 0.1 + intensity * 0.3);
      
      if (hunter.alertLevel > 0.5) {
        hunter.state = 'hunt';
      } else if (hunter.alertLevel > 0.18) {
        hunter.state = 'investigate';
        hunter.investigateTimer = 1.8 + intensity * 1.2;
      }
      
      setTimeout(function() {
        playHunterGrowl(dist, hunter.alertLevel);
      }, dist * 2);
    }
  });
}

function startCharge() {
  if (gameState !== 'playing') return;
  isCharging = true;
  chargeTime = 0;
}

function releaseCharge() {
  if (!isCharging) return;
  isCharging = false;
  
  if (chargeTime >= MIN_CHARGE) {
    const intensity = Math.min(1, (chargeTime - MIN_CHARGE) / (MAX_CHARGE - MIN_CHARGE));
    emitPulse(0.1 + intensity * 0.9);
  }
  
  chargeTime = 0;
}

function update(dt) {
  if (gameState !== 'playing') return;
  
  // Slow motion
  let effectiveDt = dt;
  if (slowMo.active) {
    effectiveDt = dt * slowMo.factor;
    slowMo.duration -= dt;
    if (slowMo.duration <= 0) {
      slowMo.active = false;
      slowMo.factor = 1;
    }
  }
  
  // Charging
  if (isCharging) {
    chargeTime += dt * 1000;
  }
  
  // Player movement
  const acceleration = 1200;
  const friction = 0.88; // per-frame multiplier at 60fps
  let ax = 0, ay = 0;
  
  if (keys['w'] || keys['arrowup']) ay -= 1;
  if (keys['s'] || keys['arrowdown']) ay += 1;
  if (keys['a'] || keys['arrowleft']) ax -= 1;
  if (keys['d'] || keys['arrowright']) ax += 1;
  
  if (ax !== 0 || ay !== 0) {
    const len = Math.hypot(ax, ay);
    ax /= len;
    ay /= len;
  }
  
  player.vx += ax * acceleration * effectiveDt;
  player.vy += ay * acceleration * effectiveDt;
  player.vx *= Math.pow(friction, effectiveDt * 60);
  player.vy *= Math.pow(friction, effectiveDt * 60);
  
  const maxSpeed = 280;
  const speed = Math.hypot(player.vx, player.vy);
  if (speed > maxSpeed) {
    player.vx = (player.vx / speed) * maxSpeed;
    player.vy = (player.vy / speed) * maxSpeed;
  }
  
  // Collision detection
  const newX = player.x + player.vx * effectiveDt;
  const newY = player.y + player.vy * effectiveDt;
  
  let canMoveX = true, canMoveY = true;
  
  walls.forEach(function(wall) {
    if (circleLineCollision(newX, player.y, player.radius, wall.x1, wall.y1, wall.x2, wall.y2)) {
      canMoveX = false;
      player.vx = 0;
    }
    if (circleLineCollision(player.x, newY, player.radius, wall.x1, wall.y1, wall.x2, wall.y2)) {
      canMoveY = false;
      player.vy = 0;
    }
  });
  
  if (canMoveX) player.x = newX;
  if (canMoveY) player.y = newY;
  
  // Player noise attracting hunters
  const playerNoise = speed / maxSpeed;
  if (playerNoise > 0.65) {
    hunters.forEach(function(hunter) {
      const dist = Math.hypot(hunter.x - player.x, hunter.y - player.y);
      if (dist < 140) {
        hunter.alertLevel = Math.min(1, hunter.alertLevel + effectiveDt * 0.05 * playerNoise);
        if (hunter.alertLevel > 0.22 && hunter.state === 'patrol') {
          hunter.state = 'investigate';
          hunter.lastHeardX = player.x;
          hunter.lastHeardY = player.y;
          hunter.investigateTimer = 1.2;
        }
      }
    });
  }
  
  // Update pulses
  for (let i = pulses.length - 1; i >= 0; i--) {
    const pulse = pulses[i];
    const prevRadius = pulse.radius;
    pulse.radius += pulse.speed * effectiveDt;
    pulse.alpha = Math.pow(1 - pulse.radius / pulse.maxRadius, 0.5);
    
    // Wall reveals
    walls.forEach(function(wall) {
      const d1 = Math.hypot(wall.x1 - pulse.x, wall.y1 - pulse.y);
      const d2 = Math.hypot(wall.x2 - pulse.x, wall.y2 - pulse.y);
      
      if ((d1 <= pulse.radius && d1 > prevRadius) || (d2 <= pulse.radius && d2 > prevRadius)) {
        const exists = revealedGeo.find(function(g) {
          return g.type === 'line' && g.x1 === wall.x1 && g.y1 === wall.y1;
        });
        
        if (!exists) {
          revealedGeo.push({
            type: 'line',
            x1: wall.x1, y1: wall.y1, x2: wall.x2, y2: wall.y2,
            alpha: 1
          });
          memoryGeo.push({
            x1: wall.x1, y1: wall.y1, x2: wall.x2, y2: wall.y2,
            alpha: 0.16
          });
          playEchoSound(Math.min(d1, d2), 'wall');
          
          // Wall particles
          const midX = (wall.x1 + wall.x2) / 2;
          const midY = (wall.y1 + wall.y2) / 2;
          for (let j = 0; j < 2; j++) {
            particles.push({
              x: midX + (Math.random() - 0.5) * 25,
              y: midY + (Math.random() - 0.5) * 25,
              vx: (Math.random() - 0.5) * 35,
              vy: (Math.random() - 0.5) * 35,
              life: 0.25,
              maxLife: 0.25,
              color: [0, 150, 150]
            });
          }
        } else {
          exists.alpha = 1;
        }
      }
    });
    
    // Fragment reveals
    fragments.forEach(function(frag) {
      if (frag.collected) return;
      const dist = Math.hypot(frag.x - pulse.x, frag.y - pulse.y);
      if (dist <= pulse.radius && dist > prevRadius) {
        frag.revealAlpha = 1;
        playEchoSound(dist, 'fragment');
      }
    });
    
    // Hunter reveals
    hunters.forEach(function(hunter) {
      const dist = Math.hypot(hunter.x - pulse.x, hunter.y - pulse.y);
      if (dist <= pulse.radius && dist > prevRadius) {
        revealedGeo.push({
          type: 'circle',
          x: hunter.x, y: hunter.y, radius: hunter.radius,
          alpha: 1,
          color: [220, 30, 30],
          isHunter: true
        });
        playEchoSound(dist, 'hunter');
        
        if (dist < 130) {
          slowMo.active = true;
          slowMo.factor = 0.15;
          slowMo.duration = 0.3;
          screenShake.intensity = 12;
          playTerrorSound();
        }
      }
    });
    
    // Exit reveal
    const exitDist = Math.hypot(exit.x - pulse.x, exit.y - pulse.y);
    if (exitDist <= pulse.radius && exitDist > prevRadius) {
      revealedGeo.push({
        type: 'circle',
        x: exit.x, y: exit.y, radius: exit.radius,
        alpha: 1,
        color: exit.open ? [0, 220, 130] : [80, 80, 80]
      });
      playEchoSound(exitDist, 'exit');
    }
    
    if (pulse.radius >= pulse.maxRadius) {
      pulses.splice(i, 1);
    }
  }
  
  // Fade revealed geometry
  for (let i = revealedGeo.length - 1; i >= 0; i--) {
    revealedGeo[i].alpha -= effectiveDt * 0.3;
    if (revealedGeo[i].alpha <= 0) {
      revealedGeo.splice(i, 1);
    }
  }
  
  // Fade memory geometry
  for (let i = memoryGeo.length - 1; i >= 0; i--) {
    memoryGeo[i].alpha -= effectiveDt * 0.01;
    if (memoryGeo[i].alpha <= 0) {
      memoryGeo.splice(i, 1);
    }
  }
  
  // Fade fragment reveals
  fragments.forEach(function(frag) {
    if (frag.revealAlpha > 0) {
      frag.revealAlpha -= effectiveDt * 0.25;
    }
  });
  
  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * effectiveDt;
    p.y += p.vy * effectiveDt;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.life -= effectiveDt;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
  
  // Collect fragments
  fragments.forEach(function(frag) {
    if (frag.collected) return;
    const dist = Math.hypot(frag.x - player.x, frag.y - player.y);
    if (dist < frag.radius + player.radius) {
      frag.collected = true;
      fragmentsCollected++;
      document.getElementById('frags').textContent = fragmentsCollected;
      playCollectSound();
      
      // Collect particles
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        particles.push({
          x: frag.x,
          y: frag.y,
          vx: Math.cos(angle) * 55,
          vy: Math.sin(angle) * 55,
          life: 0.35,
          maxLife: 0.35,
          color: [0, 220, 160]
        });
      }
      
      if (fragmentsCollected >= fragments.length) {
        exit.open = true;
        playUnlockSound();
        showMessage('Exit open', 1200);
      }
    }
  });
  
  // Update hunters
  let nearestHunterDist = Infinity;
  
  hunters.forEach(function(hunter) {
    const playerDist = Math.hypot(hunter.x - player.x, hunter.y - player.y);
    nearestHunterDist = Math.min(nearestHunterDist, playerDist);
    
    // Decay alert
    hunter.alertLevel = Math.max(0, hunter.alertLevel - effectiveDt * 0.03);
    
    if (hunter.state === 'investigate') {
      hunter.investigateTimer -= effectiveDt;
      if (hunter.investigateTimer <= 0) {
        hunter.state = 'patrol';
        hunter.alertLevel *= 0.35;
      }
    }
    
    if (hunter.alertLevel < 0.06 && hunter.state !== 'investigate') {
      hunter.state = 'patrol';
    }
    
    // Movement
    let targetX, targetY, moveSpeed;
    
    if (hunter.state === 'patrol') {
      hunter.patrolAngle += effectiveDt * 0.3;
      targetX = hunter.homeX + Math.cos(hunter.patrolAngle) * hunter.patrolRadius;
      targetY = hunter.homeY + Math.sin(hunter.patrolAngle) * hunter.patrolRadius;
      moveSpeed = hunter.speed * 0.2;
    } else if (hunter.state === 'investigate') {
      targetX = hunter.lastHeardX;
      targetY = hunter.lastHeardY;
      moveSpeed = hunter.speed * 0.42;
    } else {
      targetX = hunter.lastHeardX;
      targetY = hunter.lastHeardY;
      moveSpeed = hunter.speed * (0.5 + hunter.alertLevel * 0.5);
    }
    
    const dx = targetX - hunter.x;
    const dy = targetY - hunter.y;
    const dist = Math.hypot(dx, dy);
    
    if (dist > 3) {
      const moveX = (dx / dist) * moveSpeed * effectiveDt;
      const moveY = (dy / dist) * moveSpeed * effectiveDt;
      
      let canMove = true;
      walls.forEach(function(wall) {
        if (circleLineCollision(hunter.x + moveX, hunter.y + moveY, hunter.radius, wall.x1, wall.y1, wall.x2, wall.y2)) {
          canMove = false;
        }
      });
      
      if (canMove) {
        hunter.x += moveX;
        hunter.y += moveY;
      }
    }
    
    // Death check
    if (playerDist < hunter.radius + player.radius) {
      gameState = 'dead';
      playDeathSound();
      screenShake.intensity = 25;
      
      document.getElementById('death-screen').style.display = 'flex';
      document.getElementById('death-level').textContent = currentLevel + 1;
      document.getElementById('death-pulses').textContent = totalPulses;
    }
  });
  
  // Danger level and heartbeat
  dangerLevel = hunters.length > 0 ? Math.max(0, 1 - nearestHunterDist / 170) : 0;
  
  const vignette = document.getElementById('danger-vignette');
  vignette.style.opacity = dangerLevel * 0.5;
  vignette.style.background = 'radial-gradient(ellipse at center, transparent 20%, rgba(45,0,0,' + (dangerLevel * 0.28) + ') 100%)';
  
  heartbeatTimer -= dt;
  if (heartbeatTimer <= 0 && dangerLevel > 0.2) {
    playHeartbeat(dangerLevel);
    heartbeatTimer = 0.7 - dangerLevel * 0.3;
  }
  
  // Exit check
  if (exit.open) {
    const exitDist = Math.hypot(exit.x - player.x, exit.y - player.y);
    if (exitDist < exit.radius + player.radius) {
      playWinSound();
      loadLevel(currentLevel + 1);
    }
  }
  
  // Screen shake
  if (screenShake.intensity > 0) {
    screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
    screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
    screenShake.intensity *= 0.86;
    if (screenShake.intensity < 0.2) {
      screenShake.intensity = 0;
    }
  }
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height);
  
  ctx.save();
  ctx.translate(screenShake.x, screenShake.y);
  
  if (gameState === 'playing' || gameState === 'dead') {
    // Draw memory geometry
    ctx.lineWidth = 1;
    memoryGeo.forEach(function(m) {
      ctx.strokeStyle = 'rgba(0, 60, 60, ' + m.alpha + ')';
      ctx.beginPath();
      ctx.moveTo(m.x1, m.y1);
      ctx.lineTo(m.x2, m.y2);
      ctx.stroke();
    });
    
    // Draw revealed geometry
    revealedGeo.forEach(function(g) {
      ctx.globalAlpha = g.alpha;
      
      if (g.type === 'line') {
        ctx.strokeStyle = '#0aa';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#0aa';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(g.x1, g.y1);
        ctx.lineTo(g.x2, g.y2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else {
        const color = g.color || [0, 180, 180];
        ctx.strokeStyle = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
        ctx.lineWidth = g.isHunter ? 4 : 3;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.shadowBlur = g.isHunter ? 22 : 15;
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    });
    
    ctx.globalAlpha = 1;
    
    // Draw fragments
    fragments.forEach(function(frag) {
      if (frag.collected || frag.revealAlpha <= 0) return;
      
      ctx.globalAlpha = frag.revealAlpha;
      ctx.strokeStyle = '#0da';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#0da';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(frag.x, frag.y, frag.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Diamond shape
      ctx.beginPath();
      ctx.moveTo(frag.x, frag.y - 5);
      ctx.lineTo(frag.x + 5, frag.y);
      ctx.lineTo(frag.x, frag.y + 5);
      ctx.lineTo(frag.x - 5, frag.y);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 220, 170, ' + (frag.revealAlpha * 0.4) + ')';
      ctx.fill();
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    });
    
    // Draw pulses
    pulses.forEach(function(pulse) {
      const gradient = ctx.createRadialGradient(
        pulse.x, pulse.y, pulse.radius - 10,
        pulse.x, pulse.y, pulse.radius + 10
      );
      gradient.addColorStop(0, 'transparent');
      gradient.addColorStop(0.5, 'rgba(0, 160, 160, ' + (pulse.alpha * 0.3) + ')');
      gradient.addColorStop(1, 'transparent');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 20;
      ctx.beginPath();
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.strokeStyle = 'rgba(160, 230, 230, ' + (pulse.alpha * 0.6) + ')';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
      ctx.stroke();
    });
    
    // Draw particles
    particles.forEach(function(p) {
      const alpha = p.life / p.maxLife;
      const color = p.color || [0, 180, 180];
      ctx.fillStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + alpha + ')';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw player - ensure fully visible
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Player inner glow
    const playerGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius);
    playerGradient.addColorStop(0, 'rgba(70, 180, 180, 0.6)');
    playerGradient.addColorStop(1, 'rgba(70, 180, 180, 0)');
    ctx.fillStyle = playerGradient;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Charge indicator
    if (isCharging) {
      const chargeRatio = Math.min(1, chargeTime / MAX_CHARGE);
      ctx.strokeStyle = 'rgba(0, 220, 220, ' + (0.2 + chargeRatio * 0.45) + ')';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius + 5 + chargeRatio * 20, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * chargeRatio);
      ctx.stroke();
    }
  }
  
  ctx.restore();
}

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;
  
  update(dt);
  draw();
  
  requestAnimationFrame(gameLoop);
}

// ============ EVENT LISTENERS ============
window.addEventListener('keydown', function(e) {
  keys[e.key.toLowerCase()] = true;
  
  if (e.code === 'Space' && !e.repeat) {
    e.preventDefault();
    startCharge();
  }
});

window.addEventListener('keyup', function(e) {
  keys[e.key.toLowerCase()] = false;
  
  if (e.code === 'Space') {
    releaseCharge();
  }
});

canvas.addEventListener('mousedown', startCharge);
canvas.addEventListener('mouseup', releaseCharge);
canvas.addEventListener('mouseleave', releaseCharge);

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('retry-btn').addEventListener('click', startGame);
document.getElementById('replay-btn').addEventListener('click', startGame);

window.addEventListener('resize', resize);

// ============ INIT ============
resize();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
