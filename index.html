<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ECHO</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: system-ui, -apple-system, sans-serif; }
  canvas { display: block; }
  
  #vig { position: fixed; inset: 0; pointer-events: none; z-index: 5; opacity: 0; }
  
  #ui {
    position: fixed; inset: 0; pointer-events: none; z-index: 10;
    display: flex; flex-direction: column;
  }
  
  .hud { display: flex; justify-content: space-between; padding: 18px 22px; }
  .hud-l, .hud-r { display: flex; flex-direction: column; gap: 5px; }
  .hud-r { align-items: flex-end; }
  
  .stat { font-size: 9px; letter-spacing: 3px; text-transform: uppercase; color: rgba(255,255,255,0.25); }
  .stat span { color: rgba(0,200,200,0.55); }
  .stat.frag span { color: rgba(0,220,160,0.65); }
  
  #msg {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 12px; letter-spacing: 6px; text-transform: uppercase;
    color: #fff; opacity: 0; transition: opacity 0.4s;
    text-shadow: 0 0 18px rgba(255,255,255,0.25);
    text-align: center; line-height: 2;
  }
  
  #hint {
    position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
    font-size: 8px; letter-spacing: 2px; text-transform: uppercase;
    color: rgba(255,255,255,0.08);
  }
  
  .ov {
    position: fixed; inset: 0; display: none;
    flex-direction: column; align-items: center; justify-content: center;
    z-index: 20; pointer-events: all; background: rgba(0,0,0,0.98);
  }
  
  #title { display: flex; background: #000; }
  #title h1 {
    font-size: 55px; font-weight: 100; letter-spacing: 18px;
    color: rgba(255,255,255,0.8); margin-bottom: 6px;
    text-shadow: 0 0 25px rgba(0,200,200,0.1);
  }
  
  .sub {
    font-size: 8px; letter-spacing: 3px; text-transform: uppercase;
    color: rgba(255,255,255,0.15); text-align: center;
    line-height: 2.2; margin-bottom: 35px;
  }
  
  .btn {
    font-size: 9px; letter-spacing: 3px; text-transform: uppercase;
    color: rgba(0,200,200,0.45); background: transparent;
    border: 1px solid rgba(0,200,200,0.08); padding: 9px 24px;
    cursor: pointer; font-family: inherit; transition: all 0.2s;
  }
  .btn:hover { border-color: rgba(0,200,200,0.25); text-shadow: 0 0 8px rgba(0,200,200,0.25); }
  
  #dead h2 { font-size: 24px; font-weight: 100; letter-spacing: 10px; color: #d33; margin-bottom: 18px; text-shadow: 0 0 18px rgba(220,50,50,0.15); }
  #won h2 { font-size: 24px; font-weight: 100; letter-spacing: 10px; color: #0c8; margin-bottom: 18px; text-shadow: 0 0 18px rgba(0,200,130,0.15); }
  .info { font-size: 9px; letter-spacing: 2px; color: rgba(255,255,255,0.25); text-align: center; line-height: 2; margin-bottom: 25px; }
  .scr { font-size: 32px; font-weight: 100; letter-spacing: 5px; color: rgba(0,200,200,0.6); margin-bottom: 20px; }
  .scr-lbl { font-size: 8px; letter-spacing: 3px; color: rgba(255,255,255,0.2); text-transform: uppercase; margin-bottom: 4px; }
</style>
</head>
<body>

<div id="vig"></div>
<div id="ui">
  <div class="hud">
    <div class="hud-l"><div class="stat">Level <span id="lvl">1</span></div></div>
    <div class="hud-r">
      <div class="stat">Pulses <span id="pls">0</span></div>
      <div class="stat frag">Fragments <span id="frg">0/0</span></div>
    </div>
  </div>
  <div id="msg"></div>
  <div id="hint">Hold Space/Click Â· WASD</div>
</div>

<div class="ov" id="title">
  <h1>ECHO</h1>
  <div class="sub">Sound is sight in the dark<br>But they listen too</div>
  <button class="btn" onclick="start()">Enter</button>
</div>

<div class="ov" id="dead">
  <h2>FOUND</h2>
  <div class="info">It heard you</div>
  <div class="scr-lbl">Score</div>
  <div class="scr" id="dscore">0</div>
  <button class="btn" onclick="start()">Again</button>
</div>

<div class="ov" id="won">
  <h2>ESCAPED</h2>
  <div class="info">You found the way</div>
  <div class="scr-lbl">Final Score</div>
  <div class="scr" id="wscore">0</div>
  <button class="btn" onclick="start()">Again</button>
</div>

<canvas id="c"></canvas>

<script>
const C = document.getElementById('c');
const X = C.getContext('2d');
let W, H;

let A = null;
const init = () => {
  if (A) return;
  A = new (window.AudioContext || window.webkitAudioContext)();
  
  // Layered ambient
  const r1 = A.createOscillator();
  const g1 = A.createGain();
  r1.type = 'sine'; r1.frequency.value = 24; g1.gain.value = 0.025;
  r1.connect(g1); g1.connect(A.destination); r1.start();
  
  // High drone
  const r2 = A.createOscillator();
  const g2 = A.createGain();
  const f2 = A.createBiquadFilter();
  r2.type = 'sine'; r2.frequency.value = 1800; 
  f2.type = 'bandpass'; f2.frequency.value = 1800; f2.Q.value = 10;
  g2.gain.value = 0.003;
  r2.connect(f2); f2.connect(g2); g2.connect(A.destination); r2.start();
};

const snd = (t, p = {}) => {
  if (!A) return;
  const now = A.currentTime;
  
  if (t === 'pulse') {
    const i = p.int || 0.5;
    const o = A.createOscillator();
    const g = A.createGain();
    const f = A.createBiquadFilter();
    o.connect(f); f.connect(g); g.connect(A.destination);
    o.frequency.setValueAtTime(380 + i * 420, now);
    o.frequency.exponentialRampToValueAtTime(50 + i * 50, now + 0.5);
    f.type = 'bandpass'; f.frequency.value = 600;
    g.gain.setValueAtTime(0.055 + i * 0.045, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    o.start(now); o.stop(now + 0.5);
    
    if (i > 0.3) {
      const b = A.createOscillator();
      const bg = A.createGain();
      b.connect(bg); bg.connect(A.destination);
      b.type = 'sine'; b.frequency.setValueAtTime(38, now);
      b.frequency.exponentialRampToValueAtTime(18, now + 0.15);
      bg.gain.setValueAtTime(0.09 * i, now);
      bg.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      b.start(now); b.stop(now + 0.15);
    }
  }
  
  if (t === 'echo') {
    const d = p.dist || 100;
    const et = p.type || 'wall';
    setTimeout(() => {
      if (!A) return;
      const o = A.createOscillator();
      const g = A.createGain();
      const f = A.createBiquadFilter();
      o.connect(f); f.connect(g); g.connect(A.destination);
      
      if (et === 'hunter') {
        o.type = 'sawtooth'; o.frequency.setValueAtTime(160, A.currentTime);
        o.frequency.exponentialRampToValueAtTime(60, A.currentTime + 0.14);
        f.type = 'lowpass'; f.frequency.value = 300;
      } else if (et === 'frag') {
        o.frequency.setValueAtTime(1200, A.currentTime);
        o.frequency.exponentialRampToValueAtTime(800, A.currentTime + 0.09);
        f.type = 'highpass'; f.frequency.value = 700;
      } else if (et === 'exit') {
        o.frequency.setValueAtTime(900, A.currentTime);
        o.frequency.exponentialRampToValueAtTime(600, A.currentTime + 0.1);
        f.type = 'bandpass'; f.frequency.value = 800;
      } else {
        o.frequency.setValueAtTime(450, A.currentTime);
        o.frequency.exponentialRampToValueAtTime(120, A.currentTime + 0.09);
        f.type = 'bandpass'; f.frequency.value = 600; f.Q.value = 2;
      }
      
      const v = Math.max(0.005, 0.04 - d / 2600);
      g.gain.setValueAtTime(v, A.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.12);
      o.start(A.currentTime); o.stop(A.currentTime + 0.12);
    }, Math.min(d / 400, 0.4) * 1000);
  }
  
  if (t === 'heart') {
    const i = p.int || 0.5;
    const o = A.createOscillator();
    const g = A.createGain();
    o.connect(g); g.connect(A.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(48, now);
    o.frequency.exponentialRampToValueAtTime(32, now + 0.08);
    g.gain.setValueAtTime(0.06 * i, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    o.start(now); o.stop(now + 0.08);
    setTimeout(() => {
      if (!A) return;
      const o2 = A.createOscillator();
      const g2 = A.createGain();
      o2.connect(g2); g2.connect(A.destination);
      o2.type = 'sine'; o2.frequency.value = 38;
      g2.gain.setValueAtTime(0.035 * i, A.currentTime);
      g2.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.06);
      o2.start(A.currentTime); o2.stop(A.currentTime + 0.06);
    }, 80);
  }
  
  if (t === 'growl') {
    const d = p.dist || 200;
    const al = p.alert || 0.5;
    const v = Math.max(0.01, (0.07 - d / 1100) * al);
    const o1 = A.createOscillator();
    const o2 = A.createOscillator();
    const g = A.createGain();
    const f = A.createBiquadFilter();
    o1.connect(f); o2.connect(f); f.connect(g); g.connect(A.destination);
    o1.type = 'sawtooth'; o2.type = 'sawtooth';
    o1.frequency.value = 45 + al * 10; o2.frequency.value = 48 + al * 10;
    f.type = 'lowpass'; f.frequency.value = 110 + al * 60;
    g.gain.setValueAtTime(v, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    o1.start(now); o2.start(now); o1.stop(now + 0.3); o2.stop(now + 0.3);
  }
  
  if (t === 'step') {
    const d = p.dist || 200;
    const v = Math.max(0, 0.025 - d / 900);
    if (v <= 0) return;
    const o = A.createOscillator();
    const g = A.createGain();
    o.connect(g); g.connect(A.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(58, now);
    o.frequency.exponentialRampToValueAtTime(28, now + 0.04);
    g.gain.setValueAtTime(v, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
    o.start(now); o.stop(now + 0.04);
  }
  
  if (t === 'terror') {
    [170, 180, 191, 202].forEach(freq => {
      const o = A.createOscillator();
      const g = A.createGain();
      o.connect(g); g.connect(A.destination);
      o.type = 'sawtooth'; o.frequency.value = freq;
      g.gain.setValueAtTime(0.04, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      o.start(now); o.stop(now + 0.5);
    });
  }
  
  if (t === 'collect') {
    [700, 880, 1050].forEach((f, i) => {
      setTimeout(() => {
        if (!A) return;
        const o = A.createOscillator();
        const g = A.createGain();
        o.connect(g); g.connect(A.destination);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.05, A.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.1);
        o.start(A.currentTime); o.stop(A.currentTime + 0.1);
      }, i * 50);
    });
  }
  
  if (t === 'unlock') {
    [350, 440, 520, 680, 880].forEach((f, i) => {
      setTimeout(() => {
        if (!A) return;
        const o = A.createOscillator();
        const g = A.createGain();
        o.connect(g); g.connect(A.destination);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.06, A.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.18);
        o.start(A.currentTime); o.stop(A.currentTime + 0.18);
      }, i * 65);
    });
  }
  
  if (t === 'die') {
    for (let i = 0; i < 6; i++) {
      setTimeout(() => {
        if (!A) return;
        const o = A.createOscillator();
        const g = A.createGain();
        o.connect(g); g.connect(A.destination);
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(120 - i * 8, A.currentTime);
        o.frequency.exponentialRampToValueAtTime(14, A.currentTime + 0.28);
        g.gain.setValueAtTime(0.1, A.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.28);
        o.start(A.currentTime); o.stop(A.currentTime + 0.28);
      }, i * 35);
    }
  }
  
  if (t === 'win') {
    [523, 659, 784, 1047].forEach((f, i) => {
      setTimeout(() => {
        if (!A) return;
        const o = A.createOscillator();
        const g = A.createGain();
        o.connect(g); g.connect(A.destination);
        o.frequency.value = f;
        g.gain.setValueAtTime(0.05, A.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, A.currentTime + 0.25);
        o.start(A.currentTime); o.stop(A.currentTime + 0.25);
      }, i * 80);
    });
  }
  
  if (t === 'boss') {
    const o = A.createOscillator();
    const g = A.createGain();
    const f = A.createBiquadFilter();
    o.connect(f); f.connect(g); g.connect(A.destination);
    o.type = 'sawtooth'; o.frequency.value = 35;
    f.type = 'lowpass'; f.frequency.value = 80;
    g.gain.setValueAtTime(0.08, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
    o.start(now); o.stop(now + 0.8);
  }
};

// State
let state = 'title';
let lvl = 0, pulses = 0, score = 0;
let P = [], G = [], M = [], PT = [];
let player = { x: 0, y: 0, r: 8, vx: 0, vy: 0 };
let hunters = [];
let frags = [], fragC = 0;
let exit = { x: 0, y: 0, r: 22, open: false };
let walls = [];
let keys = {};
let charging = false, chargeT = 0;
const MAXC = 600, MINC = 55;
let shake = { x: 0, y: 0, i: 0 };
let slowmo = { on: false, f: 1, d: 0 };
let lastT = 0, hbT = 0, danger = 0;

const levels = [
  // L1: Tutorial
  { p: [105, 300], e: [695, 300], h: [], f: [[400, 175], [400, 425]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[285,85,285,365],[515,235,515,515]] },
  // L2: First hunter
  { p: [95, 300], e: [705, 300], h: [[400, 300, 65, 100]], f: [[240, 140], [560, 460], [400, 300]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[230,70,230,340],[570,260,570,530]] },
  // L3: Maze
  { p: [95, 95], e: [705, 505], h: [[400, 300, 75, 120]], f: [[140, 390], [390, 140], [590, 340], [340, 470]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[190,42,190,290],[190,370,190,h-42],[340,120,340,440],[490,42,490,350],[490,350,630,350]] },
  // L4: Two hunters
  { p: [400, 560], e: [400, 70], h: [[190, 300, 70, 85], [610, 300, 70, 85]], f: [[400, 300], [190, 140], [610, 460], [290, 460], [510, 140]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[260,160,260,440],[540,160,540,440],[260,160,540,160],[260,440,540,440]] },
  // L5: Three hunters
  { p: [95, 300], e: [705, 300], h: [[240, 160, 80, 58], [400, 440, 80, 58], [560, 160, 80, 58]], f: [[190, 300], [340, 190], [460, 410], [610, 300], [400, 300]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[42,185,160,185],[42,415,160,415],[280,85,280,245],[280,355,280,515],[520,85,520,245],[520,355,520,515],[640,185,w-42,185],[640,415,w-42,415]] },
  // L6: Boss - The Watcher (fast, persistent, larger patrol)
  { p: [400, 560], e: [400, 70], h: [[400, 300, 100, 200]], f: [[200, 200], [600, 200], [200, 400], [600, 400], [400, 300], [150, 300], [650, 300]],
    w: (w, h) => [[42,42,w-42,42],[w-42,42,w-42,h-42],[w-42,h-42,42,h-42],[42,h-42,42,42],[300,180,300,280],[300,320,300,420],[500,180,500,280],[500,320,500,420],[200,250,200,350],[600,250,600,350]] }
];

const resize = () => { W = C.width = innerWidth; H = C.height = innerHeight; };

const load = (n) => {
  if (n >= levels.length) {
    state = 'won';
    document.getElementById('won').style.display = 'flex';
    document.getElementById('wscore').textContent = score;
    snd('win');
    return;
  }
  
  const L = levels[n];
  lvl = n;
  P = []; G = []; M = []; PT = [];
  hunters = []; frags = []; fragC = 0;
  
  player.x = L.p[0]; player.y = L.p[1]; player.vx = 0; player.vy = 0;
  exit.x = L.e[0]; exit.y = L.e[1]; exit.open = L.f.length === 0;
  
  walls = L.w(W, H).map(w => ({ x1: w[0], y1: w[1], x2: w[2], y2: w[3] }));
  
  L.h.forEach(h => {
    hunters.push({
      x: h[0], y: h[1], hx: h[0], hy: h[1],
      spd: h[2], patrol: h[3], ang: Math.random() * 6.28,
      st: 'patrol', al: 0, hrdX: null, hrdY: null,
      invT: 0, stpT: 0, r: n === 5 ? 30 : 24 // Boss is bigger
    });
  });
  
  L.f.forEach(f => frags.push({ x: f[0], y: f[1], r: 12, got: false, revA: 0 }));
  
  document.getElementById('lvl').textContent = n + 1;
  document.getElementById('pls').textContent = pulses;
  document.getElementById('frg').textContent = `0/${frags.length}`;
  
  if (n === 0) msg('Collect fragments<br>Find the exit', 2500);
  else if (n === 5) { msg('THE WATCHER', 2000); snd('boss'); }
  else msg(`Level ${n + 1}`, 1800);
};

const msg = (txt, dur = 2000) => {
  const m = document.getElementById('msg');
  m.innerHTML = txt;
  m.style.opacity = '1';
  setTimeout(() => m.style.opacity = '0', dur);
};

const start = () => {
  init();
  ['title', 'dead', 'won'].forEach(id => document.getElementById(id).style.display = 'none');
  pulses = 0; score = 0;
  state = 'play';
  load(0);
};

const emit = (int) => {
  if (state !== 'play') return;
  pulses++;
  document.getElementById('pls').textContent = pulses;
  
  P.push({ x: player.x, y: player.y, r: 0, maxR: 140 + int * 420, spd: 230 + int * 140, a: 1, int });
  snd('pulse', { int });
  shake.i = 1.2 + int * 4.5;
  
  const n = 5 + Math.floor(int * 9);
  for (let i = 0; i < n; i++) {
    const a = (i / n) * 6.28;
    PT.push({ x: player.x, y: player.y, vx: Math.cos(a) * (65 + int * 45), vy: Math.sin(a) * (65 + int * 45), life: 0.3 + int * 0.2, max: 0.3 + int * 0.2 });
  }
  
  hunters.forEach(h => {
    const d = Math.hypot(h.x - player.x, h.y - player.y);
    const hr = 180 + int * 360;
    if (d < hr) {
      h.hrdX = player.x; h.hrdY = player.y;
      h.al = Math.min(1, h.al + 0.08 + int * 0.28);
      if (h.al > 0.45) h.st = 'hunt';
      else if (h.al > 0.15) { h.st = 'inv'; h.invT = 1.5 + int * 1; }
      setTimeout(() => snd('growl', { dist: d, alert: h.al }), d * 1.8);
    }
  });
};

const startC = () => { if (state === 'play') { charging = true; chargeT = 0; } };
const relC = () => {
  if (!charging) return;
  charging = false;
  if (chargeT >= MINC) {
    const int = Math.min(1, (chargeT - MINC) / (MAXC - MINC));
    emit(0.08 + int * 0.92);
  }
  chargeT = 0;
};

const ptLn = (px, py, x1, y1, x2, y2) => {
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D, len = C*C + D*D;
  let t = len ? dot/len : -1;
  if (t < 0) t = 0; else if (t > 1) t = 1;
  return Math.hypot(px - (x1 + t*C), py - (y1 + t*D));
};
const circLn = (cx, cy, r, x1, y1, x2, y2) => ptLn(cx, cy, x1, y1, x2, y2) < r;

const update = (dt) => {
  if (state !== 'play') return;
  
  let edt = dt;
  if (slowmo.on) {
    edt = dt * slowmo.f;
    slowmo.d -= dt;
    if (slowmo.d <= 0) { slowmo.on = false; slowmo.f = 1; }
  }
  
  if (charging) chargeT += dt * 1000;
  
  // Player
  const acc = 580, fric = 5.8;
  let ax = 0, ay = 0;
  if (keys.w || keys.ArrowUp) ay--;
  if (keys.s || keys.ArrowDown) ay++;
  if (keys.a || keys.ArrowLeft) ax--;
  if (keys.d || keys.ArrowRight) ax++;
  if (ax || ay) { const l = Math.hypot(ax, ay); ax /= l; ay /= l; }
  
  player.vx += ax * acc * edt;
  player.vy += ay * acc * edt;
  player.vx *= Math.pow(0.001, edt * fric);
  player.vy *= Math.pow(0.001, edt * fric);
  
  const maxS = 155;
  const spd = Math.hypot(player.vx, player.vy);
  if (spd > maxS) { player.vx = (player.vx/spd)*maxS; player.vy = (player.vy/spd)*maxS; }
  
  const nx = player.x + player.vx * edt;
  const ny = player.y + player.vy * edt;
  
  let canX = true, canY = true;
  for (const w of walls) {
    if (circLn(nx, player.y, player.r, w.x1, w.y1, w.x2, w.y2)) { canX = false; player.vx = 0; }
    if (circLn(player.x, ny, player.r, w.x1, w.y1, w.x2, w.y2)) { canY = false; player.vy = 0; }
  }
  if (canX) player.x = nx;
  if (canY) player.y = ny;
  
  // Player noise
  const pNoise = spd / maxS;
  if (pNoise > 0.6) {
    hunters.forEach(h => {
      const d = Math.hypot(h.x - player.x, h.y - player.y);
      if (d < 130) {
        h.al = Math.min(1, h.al + edt * 0.05 * pNoise);
        if (h.al > 0.2 && h.st === 'patrol') {
          h.st = 'inv'; h.hrdX = player.x; h.hrdY = player.y; h.invT = 1;
        }
      }
    });
  }
  
  // Pulses
  for (let i = P.length - 1; i >= 0; i--) {
    const p = P[i];
    const prev = p.r;
    p.r += p.spd * edt;
    p.a = Math.pow(1 - p.r / p.maxR, 0.45);
    
    for (const w of walls) {
      const d1 = Math.hypot(w.x1 - p.x, w.y1 - p.y);
      const d2 = Math.hypot(w.x2 - p.x, w.y2 - p.y);
      if ((d1 <= p.r && d1 > prev) || (d2 <= p.r && d2 > prev)) {
        const ex = G.find(g => g.t === 'l' && g.x1 === w.x1 && g.y1 === w.y1);
        if (!ex) {
          G.push({ t: 'l', x1: w.x1, y1: w.y1, x2: w.x2, y2: w.y2, a: 1 });
          M.push({ x1: w.x1, y1: w.y1, x2: w.x2, y2: w.y2, a: 0.14 });
          snd('echo', { dist: Math.min(d1, d2), type: 'wall' });
          const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
          for (let j = 0; j < 2; j++) PT.push({ x: mx + (Math.random()-0.5)*22, y: my + (Math.random()-0.5)*22, vx: (Math.random()-0.5)*30, vy: (Math.random()-0.5)*30, life: 0.22, max: 0.22, c: [0,140,140] });
        } else ex.a = 1;
      }
    }
    
    for (const f of frags) {
      if (f.got) continue;
      const d = Math.hypot(f.x - p.x, f.y - p.y);
      if (d <= p.r && d > prev) { f.revA = 1; snd('echo', { dist: d, type: 'frag' }); }
    }
    
    for (const h of hunters) {
      const d = Math.hypot(h.x - p.x, h.y - p.y);
      if (d <= p.r && d > prev) {
        G.push({ t: 'c', x: h.x, y: h.y, r: h.r, a: 1, c: [200,25,25], hun: true });
        snd('echo', { dist: d, type: 'hunter' });
        if (d < 120) { slowmo.on = true; slowmo.f = 0.12; slowmo.d = 0.28; shake.i = 11; snd('terror'); }
      }
    }
    
    const ed = Math.hypot(exit.x - p.x, exit.y - p.y);
    if (ed <= p.r && ed > prev) {
      G.push({ t: 'c', x: exit.x, y: exit.y, r: exit.r, a: 1, c: exit.open ? [0,200,120] : [70,70,70] });
      snd('echo', { dist: ed, type: 'exit' });
    }
    
    if (p.r >= p.maxR) P.splice(i, 1);
  }
  
  // Fade
  for (let i = G.length - 1; i >= 0; i--) { G[i].a -= edt * 0.28; if (G[i].a <= 0) G.splice(i, 1); }
  for (let i = M.length - 1; i >= 0; i--) { M[i].a -= edt * 0.009; if (M[i].a <= 0) M.splice(i, 1); }
  for (const f of frags) if (f.revA > 0) f.revA -= edt * 0.22;
  
  for (let i = PT.length - 1; i >= 0; i--) {
    const pt = PT[i];
    pt.x += pt.vx * edt; pt.y += pt.vy * edt;
    pt.vx *= 0.94; pt.vy *= 0.94;
    pt.life -= edt;
    if (pt.life <= 0) PT.splice(i, 1);
  }
  
  // Collect frags
  for (const f of frags) {
    if (f.got) continue;
    if (Math.hypot(f.x - player.x, f.y - player.y) < f.r + player.r) {
      f.got = true; fragC++;
      score += 100 * (lvl + 1);
      document.getElementById('frg').textContent = `${fragC}/${frags.length}`;
      snd('collect');
      for (let i = 0; i < 9; i++) {
        const a = (i / 9) * 6.28;
        PT.push({ x: f.x, y: f.y, vx: Math.cos(a) * 50, vy: Math.sin(a) * 50, life: 0.3, max: 0.3, c: [0,200,150] });
      }
      if (fragC >= frags.length) { exit.open = true; snd('unlock'); msg('Exit open', 1100); }
    }
  }
  
  // Hunters
  let nearD = Infinity;
  for (const h of hunters) {
    const pd = Math.hypot(h.x - player.x, h.y - player.y);
    nearD = Math.min(nearD, pd);
    
    h.al = Math.max(0, h.al - edt * 0.025);
    if (h.st === 'inv') { h.invT -= edt; if (h.invT <= 0) { h.st = 'patrol'; h.al *= 0.3; } }
    if (h.al < 0.05 && h.st !== 'inv') h.st = 'patrol';
    
    let tx, ty, ms;
    if (h.st === 'patrol') {
      h.ang += edt * 0.28;
      tx = h.hx + Math.cos(h.ang) * h.patrol;
      ty = h.hy + Math.sin(h.ang) * h.patrol;
      ms = h.spd * 0.18;
    } else if (h.st === 'inv') {
      tx = h.hrdX; ty = h.hrdY;
      ms = h.spd * 0.38;
    } else {
      tx = h.hrdX; ty = h.hrdY;
      ms = h.spd * (0.48 + h.al * 0.52);
    }
    
    const dx = tx - h.x, dy = ty - h.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 2) {
      const mx = (dx/dist) * ms * edt;
      const my = (dy/dist) * ms * edt;
      let can = true;
      for (const w of walls) if (circLn(h.x + mx, h.y + my, h.r, w.x1, w.y1, w.x2, w.y2)) { can = false; break; }
      if (can) {
        h.x += mx; h.y += my;
        h.stpT -= edt;
        if (h.stpT <= 0 && h.st !== 'patrol') { snd('step', { dist: pd }); h.stpT = 0.28; }
      }
    }
    
    if (pd < h.r + player.r) {
      state = 'dead';
      snd('die');
      shake.i = 22;
      document.getElementById('dead').style.display = 'flex';
      document.getElementById('dscore').textContent = score;
    }
  }
  
  // Danger
  danger = hunters.length ? Math.max(0, 1 - nearD / 160) : 0;
  const vig = document.getElementById('vig');
  vig.style.opacity = danger * 0.45;
  vig.style.background = `radial-gradient(ellipse at center, transparent 18%, rgba(40,0,0,${danger * 0.25}) 100%)`;
  
  hbT -= dt;
  if (hbT <= 0 && danger > 0.18) { snd('heart', { int: danger }); hbT = 0.65 - danger * 0.28; }
  
  // Exit
  if (exit.open && Math.hypot(exit.x - player.x, exit.y - player.y) < exit.r + player.r) {
    score += 200 * (lvl + 1);
    score += Math.max(0, 500 - pulses * 4);
    snd('win');
    load(lvl + 1);
  }
  
  // Shake
  if (shake.i > 0) { shake.x = (Math.random() - 0.5) * shake.i; shake.y = (Math.random() - 0.5) * shake.i; shake.i *= 0.84; if (shake.i < 0.18) shake.i = 0; }
};

const draw = () => {
  X.fillStyle = '#000';
  X.fillRect(0, 0, W, H);
  
  X.save();
  X.translate(shake.x, shake.y);
  
  if (state === 'play' || state === 'dead') {
    X.lineWidth = 1;
    for (const m of M) { X.strokeStyle = `rgba(0,55,55,${m.a})`; X.beginPath(); X.moveTo(m.x1, m.y1); X.lineTo(m.x2, m.y2); X.stroke(); }
    
    for (const g of G) {
      X.globalAlpha = g.a;
      if (g.t === 'l') {
        X.strokeStyle = '#099'; X.lineWidth = 2; X.shadowColor = '#099'; X.shadowBlur = 9;
        X.beginPath(); X.moveTo(g.x1, g.y1); X.lineTo(g.x2, g.y2); X.stroke(); X.shadowBlur = 0;
      } else {
        const c = g.c || [0,160,160];
        X.strokeStyle = `rgb(${c[0]},${c[1]},${c[2]})`; X.lineWidth = g.hun ? 4 : 3;
        X.shadowColor = X.strokeStyle; X.shadowBlur = g.hun ? 20 : 13;
        X.beginPath(); X.arc(g.x, g.y, g.r, 0, 6.28); X.stroke(); X.shadowBlur = 0;
      }
    }
    X.globalAlpha = 1;
    
    for (const f of frags) {
      if (f.got || f.revA <= 0) continue;
      X.globalAlpha = f.revA;
      X.strokeStyle = '#0c9'; X.lineWidth = 2; X.shadowColor = '#0c9'; X.shadowBlur = 10;
      X.beginPath(); X.arc(f.x, f.y, f.r, 0, 6.28); X.stroke();
      X.beginPath(); X.moveTo(f.x, f.y - 4); X.lineTo(f.x + 4, f.y); X.lineTo(f.x, f.y + 4); X.lineTo(f.x - 4, f.y); X.closePath();
      X.fillStyle = `rgba(0,200,150,${f.revA * 0.35})`; X.fill(); X.shadowBlur = 0; X.globalAlpha = 1;
    }
    
    for (const p of P) {
      const gr = X.createRadialGradient(p.x, p.y, p.r - 9, p.x, p.y, p.r + 9);
      gr.addColorStop(0, 'transparent'); gr.addColorStop(0.5, `rgba(0,150,150,${p.a * 0.28})`); gr.addColorStop(1, 'transparent');
      X.strokeStyle = gr; X.lineWidth = 18; X.beginPath(); X.arc(p.x, p.y, p.r, 0, 6.28); X.stroke();
      X.strokeStyle = `rgba(150,220,220,${p.a * 0.55})`; X.lineWidth = 2; X.beginPath(); X.arc(p.x, p.y, p.r, 0, 6.28); X.stroke();
    }
    
    for (const pt of PT) {
      const a = pt.life / pt.max;
      const c = pt.c || [0,170,170];
      X.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a})`;
      X.beginPath(); X.arc(pt.x, pt.y, 1.8, 0, 6.28); X.fill();
    }
    
    X.fillStyle = '#fff'; X.shadowColor = '#fff'; X.shadowBlur = 12;
    X.beginPath(); X.arc(player.x, player.y, player.r, 0, 6.28); X.fill(); X.shadowBlur = 0;
    
    const pg = X.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.r);
    pg.addColorStop(0, 'rgba(65,170,170,0.55)'); pg.addColorStop(1, 'rgba(65,170,170,0)');
    X.fillStyle = pg; X.beginPath(); X.arc(player.x, player.y, player.r, 0, 6.28); X.fill();
    
    if (charging) {
      const ch = Math.min(1, chargeT / MAXC);
      X.strokeStyle = `rgba(0,210,210,${0.18 + ch * 0.4})`; X.lineWidth = 2;
      X.beginPath(); X.arc(player.x, player.y, player.r + 4 + ch * 18, -1.57, -1.57 + 6.28 * ch); X.stroke();
    }
  }
  
  X.restore();
};

const loop = (t) => { const dt = Math.min((t - lastT) / 1000, 0.1); lastT = t; update(dt); draw(); requestAnimationFrame(loop); };

addEventListener('keydown', e => { if (e.code === 'Space' && !e.repeat) { e.preventDefault(); startC(); } keys[e.key.toLowerCase()] = true; keys[e.code] = true; });
addEventListener('keyup', e => { if (e.code === 'Space') relC(); keys[e.key.toLowerCase()] = false; keys[e.code] = false; });
C.addEventListener('mousedown', startC);
C.addEventListener('mouseup', relC);
C.addEventListener('mouseleave', relC);
addEventListener('resize', resize);

resize();
requestAnimationFrame(loop);
</script>
</body>
</html>
